<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>成都理工大學數字孿生模型</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Rajdhani:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="./three.js"></script>
    <script src="./OrbitControls.js"></script>
    <script src="./GLTFLoader.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#00f3ff',
                        secondary: '#ff00d6',
                        accent: '#39ff14',
                        dark: '#0a0a12',
                        light: '#F8FAFC',
                        'neon-blue': '#00f3ff',
                        'neon-pink': '#ff00d6',
                        'neon-green': '#39ff14',
                        'neon-yellow': '#ffee00',
                        'dark-1': '#0a0a12',
                        'dark-2': '#12121d',
                        'dark-3': '#1a1a28',
                    },
                    fontFamily: {
                        orbitron: ['Orbitron', 'sans-serif'],
                        rajdhani: ['Rajdhani', 'sans-serif'],
                    },
                    animation: {
                        'pulse-glow': 'pulse-glow 2s ease-in-out infinite',
                        'glow': 'glow 2s ease-in-out infinite alternate',
                        'scanline': 'scanline 10s linear infinite',
                        'flicker': 'flicker 0.5s ease-in-out infinite',
                    },
                    keyframes: {
                        'pulse-glow': {
                            '0%, 100%': { boxShadow: '0 0 5px #00f3ff, 0 0 10px #00f3ff, 0 0 15px #00f3ff' },
                            '50%': { boxShadow: '0 0 10px #00f3ff, 0 0 20px #00f3ff, 0 0 30px #00f3ff' }
                        },
                        'glow': {
                            '0%': { boxShadow: '0 0 5px currentColor, 0 0 10px currentColor' },
                            '100%': { boxShadow: '0 0 15px currentColor, 0 0 30px currentColor' }
                        },
                        'scanline': {
                            '0%': { transform: 'translateY(-100%)' },
                            '100%': { transform: 'translateY(100vh)' }
                        },
                        'flicker': {
                            '0%, 100%': { opacity: 1 },
                            '50%': { opacity: 0.7 }
                        }
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer base {
            body {
                @apply font-rajdhani;
            }

            h1, h2, h3, h4, .tech-font {
                @apply font-orbitron;
            }
        }

        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }

            .backdrop-blur {
                backdrop-filter: blur(8px);
            }

            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            }

            .neon-text {
                text-shadow: 0 0 5px currentColor, 0 0 10px currentColor, 0 0 15px currentColor;
            }

            .tech-border {
                border: 1px solid;
                border-image: linear-gradient(45deg, #00f3ff, #ff00d6, #39ff14) 1;
                box-shadow: 0 0 10px rgba(0, 243, 255, 0.3), inset 0 0 10px rgba(0, 243, 255, 0.1);
            }

            .tech-panel {
                @apply bg-dark-2/90 backdrop-blur border border-neon-blue/30 rounded-lg;
                box-shadow: 0 0 20px rgba(0, 243, 255, 0.1), inset 0 0 20px rgba(0, 243, 255, 0.05);
            }

            .hex-pattern {
                background-image: linear-gradient(to right, rgba(10, 10, 18, 0.9) 20%, rgba(10, 10, 18, 0.7) 40%, rgba(10, 10, 18, 0.9) 60%), radial-gradient(circle at 50% 50%, rgba(0, 243, 255, 0.1) 0%, transparent 2%);
                background-size: 100% 100%, 30px 30px;
                background-position: 0 0, 0 0;
            }

            .grid-pattern {
                background-image: linear-gradient(rgba(0, 243, 255, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 243, 255, 0.1) 1px, transparent 1px);
                background-size: 20px 20px;
            }

            .control-btn {
                @apply p-3 rounded-lg transition-all duration-300 bg-dark-3/80 border border-neon-blue/30;
            }

                .control-btn:hover {
                    @apply bg-neon-blue/20 border-neon-blue/70 animate-pulse-glow;
                }

                .control-btn:active {
                    @apply scale-95;
                }

            .axis-btn {
                @apply w-10 h-10 rounded-lg flex items-center justify-center transition-all duration-300 bg-dark-3/80 border border-neon-blue/30;
            }

            .panel {
                @apply tech-panel transition-all duration-300;
            }

            .scanline-effect::after {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(to bottom, transparent 0%, rgba(0, 243, 255, 0.1) 50%, transparent 100%);
                opacity: 0.1;
                pointer-events: none;
                animation: scanline 8s linear infinite;
                z-index: 100;
            }

            .mobile-control {
                @apply fixed w-12 h-12 rounded-lg bg-dark-3/80 border border-neon-blue/30 flex items-center justify-center shadow-lg transition-all duration-200;
            }

                .mobile-control:hover {
                    @apply bg-neon-blue/20 border-neon-blue/70;
                }

                .mobile-control:active {
                    @apply scale-90;
                }

            input[type="range"] {
                @apply appearance-none w-full h-1 bg-white/20 rounded-full outline-none;
            }

                input[type="range"]::-webkit-slider-thumb {
                    @apply appearance-none w-3 h-3 bg-neon-blue rounded-full cursor-pointer;
                    box-shadow: 0 0 5px #00f3ff, 0 0 10px #00f3ff;
                }

                input[type="range"]::-moz-range-thumb {
                    @apply w-3 h-3 bg-neon-blue rounded-full cursor-pointer border-none;
                    box-shadow: 0 0 5px #00f3ff, 0 0 10px #00f3ff;
                }

            .slider-value {
                @apply text-xs text-light/60 mt-1 flex justify-between;
            }

            .building-list-item {
                @apply p-2 rounded-lg hover:bg-neon-blue/10 cursor-pointer transition-all duration-200 text-sm border-b border-neon-blue/10;
            }

                .building-list-item.active {
                    @apply bg-neon-blue/20 text-neon-blue;
                    box-shadow: inset 0 0 10px rgba(0, 243, 255, 0.2);
                }

            .search-container {
                @apply relative w-full mb-4;
            }

            .search-results {
                @apply relative w-full max-h-60 overflow-y-auto;
            }

            .search-result-item {
                @apply p-2 hover:bg-neon-blue/10 cursor-pointer transition-all text-sm border-b border-neon-blue/10;
            }

            .connection-toast {
                @apply fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-neon-blue/90 backdrop-blur px-6 py-4 rounded-lg text-dark-1 text-center z-50 opacity-0 transition-opacity duration-300;
                box-shadow: 0 4px 20px rgba(0, 243, 255, 0.5);
            }

            .loading-spinner {
                border: 2px solid transparent;
                border-top: 2px solid #00f3ff;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                box-shadow: 0 0 10px #00f3ff, 0 0 20px #00f3ff;
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }

                100% {
                    transform: rotate(360deg);
                }
            }

            .data-panel {
                @apply tech-panel p-3;
            }

            .data-value {
                @apply text-neon-blue font-orbitron text-lg;
            }

            .data-label {
                @apply text-xs text-light/60;
            }

            .pulse-element {
                animation: pulse-glow 2s infinite;
            }

            @media (min-width: 768px) {
                .data-panel {
                    top: 6rem !important;
                    left: 1rem !important;
                    right: auto !important;
                }
            }

            @media (max-width: 768px) {
                header {
                    width: 100% !important;
                    padding: 0.5rem !important;
                }

                    header .container {
                        flex-direction: row !important;
                        align-items: center !important;
                        justify-content: space-between !important;
                        width: 100% !important;
                        padding: 0 0.5rem !important;
                    }

                .title-section {
                    display: flex !important;
                    flex-direction: column !important;
                    align-items: flex-start !important;
                    justify-content: center !important;
                    flex: 1 !important;
                    margin: 0 !important;
                    padding: 0 !important;
                }

                    .title-section h1 {
                        margin: 0 !important;
                        padding: 0 !important;
                        line-height: 1.2 !important;
                    }

                .developer-text {
                    display: block !important;
                    margin: 0 !important;
                    padding: 0 !important;
                    font-size: 0.7rem !important;
                    width: 100% !important;
                }

                header .flex {
                    display: flex !important;
                    flex-direction: row !important;
                    align-items: center !important;
                    gap: 0.5rem !important;
                    padding: 0 !important;
                    margin: 0 !important;
                    min-width: auto !important;
                }

                    header .flex button {
                        padding: 0.4rem !important;
                    }

                #buildingsPanel {
                    width: 180px !important;
                    padding: 0.4rem !important;
                }

                    #buildingsPanel h3 {
                        font-size: 0.8rem !important;
                        margin-bottom: 0.4rem !important;
                    }

                #modalContent {
                    max-width: 240px !important;
                    padding: 0.6rem !important;
                }

                    #modalContent h2 {
                        font-size: 1.0rem !important;
                    }

                    #modalContent p, #modalContent li {
                        font-size: 0.75rem !important;
                    }

                .mobile-control {
                    width: 40px !important;
                    height: 40px !important;
                }

                    .mobile-control i {
                        font-size: 1rem !important;
                    }

                #mobileResetView {
                    bottom: 90px !important;
                    left: 12px !important;
                }

                #mobileOrbitToggle {
                    bottom: 12px !important;
                    left: 12px !important;
                }

                #mobileWireframeToggle {
                    top: 70px !important;
                    right: 12px !important;
                }

                #controlPanel {
                    display: flex !important;
                    bottom: 20px !important;
                    left: 50% !important;
                    transform: translateX(-50%) scale(0.85) !important;
                    width: 90% !important;
                    max-width: 270px !important;
                    z-index: 40 !important;
                }

                .control-btn {
                    padding: 0.6rem !important;
                }

                    .control-btn i {
                        font-size: 0.85rem !important;
                    }

                .mobile-fps-panel {
                    padding: 0.5rem !important;
                    top: 70px !important;
                    left: 10px !important;
                }

                .mobile-fps-value {
                    font-size: 0.8rem !important;
                }

                .mobile-fps-label {
                    font-size: 0.6rem !important;
                }

                @media (max-width: 768px) and (orientation: landscape) {
                    #buildingsPanel {
                        width: 220px !important;
                        max-height: 50vh !important;
                        top: 140px !important;
                        right: 10px !important;
                        overflow-y: auto !important;
                    }

                    #buildingSearch {
                        font-size: 0.8rem !important;
                        padding: 0.3rem !important;
                    }

                    .building-list-item {
                        font-size: 0.75rem !important;
                        padding: 0.3rem !important;
                    }

                    #modalContent {
                        max-width: 60vw !important;
                        max-height: 80vh !important;
                        overflow-y: auto !important;
                        padding: 0.8rem !important;
                    }

                        #modalContent h2 {
                            font-size: 0.9rem !important;
                            margin-bottom: 0.5rem !important;
                        }

                        #modalContent p, #modalContent li {
                            font-size: 0.7rem !important;
                            line-height: 1.4 !important;
                        }

                    #controlPanel {
                        bottom: 10px !important;
                        transform: translateX(-50%) scale(0.8) !important;
                    }
                }
            }
        }
    </style>
</head>
<body class="bg-dark-1 text-light font-rajdhani overflow-hidden h-screen hex-pattern">
    <div id="connectionToast" class="connection-toast font-orbitron">
        系統連線成功
    </div>

    <div class="fixed top-20 left-4 z-40 data-panel scanline-effect mobile-fps-panel">
        <div class="flex items-center space-x-2">
            <div class="w-2 h-2 bg-neon-green rounded-full animate-pulse"></div>
            <div>
                <div class="data-value mobile-fps-value" id="fpsCounter">60 FPS</div>
                <div class="data-label mobile-fps-label">渲染性能</div>
            </div>
        </div>
    </div>

    <header class="fixed top-0 left-0 right-0 z-50 bg-dark-2/80 backdrop-blur transition-all duration-300 border-b border-neon-blue/20">
        <div class="container mx-auto px-4 py-3 flex flex-col md:flex-row justify-between items-center">
            <div class="title-section flex flex-col items-start w-full md:w-auto mb-3 md:mb-0">
                <h1 class="text-[clamp(1.2rem,3vw,1.8rem)] font-bold text-neon-pink neon-text">META<span class="text-neon-blue">CDUT</span></h1>
                <span class="developer-text text-xs text-neon-blue/80">Developed by unq</span>
            </div>

            <div class="flex items-center space-x-2 w-full md:w-auto justify-end">
                <button id="infoBtn" class="control-btn" title="系统信息">
                    <i class="fa fa-info text-neon-blue"></i>
                </button>
                <button id="fullscreenBtn" class="control-btn" title="全屏模式">
                    <i class="fa fa-expand text-neon-blue"></i>
                </button>
                <button id="toggleBuildingsBtn" class="control-btn" title="建筑列表">
                    <i class="fa fa-building text-neon-blue"></i>
                </button>
            </div>
        </div>
    </header>

    <main class="relative h-full w-full scanline-effect">
        <canvas id="viewerCanvas" class="w-full h-full"></canvas>

        <div id="initialLoading" class="absolute inset-0 flex items-center justify-center bg-dark-1/90 z-50 grid-pattern">
            <div class="flex flex-col items-center">
                <div class="w-16 h-16 loading-spinner"></div>
                <p id="loadingStatus" class="mt-4 text-neon-blue font-orbitron">環境初始化中...</p>
                <div class="mt-2 w-48 h-1 bg-neon-blue/20 rounded-full overflow-hidden">
                    <div class="h-full bg-neon-blue w-1/2" style="box-shadow: 0 0 10px #00f3ff;"></div>
                </div>
            </div>
        </div>

        <div id="resourceError" class="absolute inset-0 flex items-center justify-center bg-dark-1/90 z-50 hidden">
            <div class="text-center p-6 tech-panel max-w-md">
                <i class="fa fa-exclamation-triangle text-neon-pink text-5xl mb-4"></i>
                <h2 class="text-xl font-bold text-neon-pink mb-2 font-orbitron">系統錯誤</h2>
                <p class="text-light/80 mb-6">無法加載3D渲染庫</p>
                <button id="retryLoadResources" class="px-6 py-3 bg-neon-blue text-dark-1 font-orbitron hover:bg-neon-blue/80 rounded-lg transition-all">
                    重新嘗試
                </button>
            </div>
        </div>

        <div id="loadingIndicator" class="absolute inset-0 flex items-center justify-center bg-dark-1/90 z-40 transition-opacity duration-500 hidden">
            <div class="flex flex-col items-center">
                <div class="w-16 h-16 loading-spinner"></div>
                <p id="loadingStatusText" class="mt-4 text-neon-blue font-orbitron">伺服器通信中...</p>
                <div id="loadingProgress" class="mt-2 w-48 h-1 bg-neon-blue/20 rounded-full overflow-hidden">
                    <div id="progressBar" class="h-full bg-neon-blue w-0 transition-all duration-300" style="box-shadow: 0 0 10px #00f3ff;"></div>
                </div>
            </div>
        </div>

        <div class="fixed md:hidden">
            <button id="mobileResetView" class="mobile-control bottom-20 left-6" title="重置视图">
                <i class="fa fa-home text-neon-blue"></i>
            </button>
            <button id="mobileOrbitToggle" class="mobile-control bottom-6 left-6" title="切换自动旋转">
                <i class="fa fa-refresh text-neon-blue"></i>
            </button>
            <button id="mobileWireframeToggle" class="mobile-control top-24 right-6" title="切换线框模式">
                <i class="fa fa-cubes text-neon-blue"></i>
            </button>
        </div>

    </main>

    <div class="fixed bottom-6 left-1/2 transform -translate-x-1/2 panel px-4 py-2 flex items-center space-x-4 z-40 opacity-100 pointer-events-auto transition-all duration-300 hidden md:flex" id="controlPanel">
        <button id="cameraOrbitToggle" class="control-btn" title="切换自动旋转">
            <i class="fa fa-refresh text-neon-blue"></i>
        </button>
        <button id="resetView" class="control-btn" title="重置视图">
            <i class="fa fa-home text-neon-blue"></i>
        </button>
        <button id="zoomIn" class="control-btn" title="放大">
            <i class="fa fa-search-plus text-neon-blue"></i>
        </button>
        <button id="zoomOut" class="control-btn" title="缩小">
            <i class="fa fa-search-minus text-neon-blue"></i>
        </button>
        <button id="wireframeToggle" class="control-btn" title="切换线框模式">
            <i class="fa fa-cubes text-neon-blue"></i>
        </button>
    </div>

    <div id="buildingsPanel" class="fixed top-[53%] right-4 transform -translate-y-1/2 panel p-4 w-64 opacity-0 pointer-events-none transition-all duration-300 z-40">
        <h3 class="font-bold text-neon-blue mb-4 flex items-center font-orbitron">
            <i class="fa fa-building mr-2"></i>建築數據庫
        </h3>

        <div class="search-container">
            <input type="text" id="buildingSearch" placeholder="搜索建築..."
                   class="w-full bg-dark-3/50 border border-neon-blue/30 rounded-lg px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-neon-blue/50 text-light placeholder-neon-blue/50">
        </div>

        <div id="buildingsList" class="search-results">
            <div class="text-neon-blue/60 text-sm text-center py-4">加載建築數據中...</div>
        </div>
    </div>

    <div id="infoModal" class="fixed inset-0 bg-black/60 backdrop-blur z-50 flex items-center justify-center hidden">
        <div class="panel p-6 max-w-md w-full mx-4 transform transition-all duration-300 scale-95 opacity-0" id="modalContent">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-neon-blue font-orbitron">系統操作指南</h2>
                <button id="closeInfoBtn" class="text-light hover:text-neon-blue transition-colors">
                    <i class="fa fa-times"></i>
                </button>
            </div>
            <div class="space-y-4">
                <p class="text-light/80">成都理工大學數字孿生系統 - 版本 1.0.1</p>

                <div class="pt-2 border-t border-neon-blue/10">
                    <h3 class="font-semibold mb-2 text-neon-blue">桌面端控制方式：</h3>
                    <ul class="space-y-1 text-light/80">
                        <li><i class="fa fa-hand-paper-o mr-2 text-neon-blue"></i> 滚轮键拖拽 - 平移相机</li>
                        <li><i class="fa fa-hand-pointer-o mr-2 text-neon-blue"></i> 左键拖拽 - 旋转视角</li>
                        <li><i class="fa fa-search mr-2 text-neon-blue"></i> 滚轮 - 缩放相机</li>
                        <li><i class="fa fa-hand-pointer-o mr-2 text-neon-blue"></i> 双击 - 设置旋转中心</li>
                        <li><i class="fa fa-keyboard-o mr-2 text-neon-blue"></i> WASD - 平移相机</li>
                        <li><i class="fa fa-keyboard-o mr-2 text-neon-blue"></i> 上下键 - 摄像机上下移动</li>
                    </ul>
                </div>

                <div class="pt-2 border-t border-neon-blue/10">
                    <h3 class="font-semibold mb-2 text-neon-blue">移動端控制方式：</h3>
                    <ul class="space-y-1 text-light/80">
                        <li><i class="fa fa-hand-pointer-o mr-2 text-neon-blue"></i> 单指拖拽 - 旋转视角</li>
                        <li><i class="fa fa-hand-rock-o mr-2 text-neon-blue"></i> 双指拖拽 - 平移相机</li>
                        <li><i class="fa fa-arrows-alt mr-2 text-neon-blue"></i> 双指捏合/张开 - 缩放</li>
                    </ul>
                </div>

                <div class="pt-2 border-t border-neon-blue/10">
                    <h3 class="font-semibold mb-2 text-neon-blue">通用控制：</h3>
                    <ul class="space-y-1 text-light/80">
                        <li><i class="fa fa-refresh mr-2 text-neon-blue"></i> 切换自动旋转</li>
                        <li><i class="fa fa-home mr-2 text-neon-blue"></i> 重置视图</li>
                        <li><i class="fa fa-cubes mr-2 text-neon-blue"></i> 切换线框模式</li>
                        <li><i class="fa fa-list mr-2 text-neon-blue"></i> 建筑列表</li>
                    </ul>
                </div>

                <div class="pt-2 border-t border-neon-blue/10 text-xs text-neon-blue/60">
                    <p>© 2025 成都理工大学数字孿生計劃</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls, model;
        let ambientLight, directionalLight, cameraLight;
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        let isOrbiting = false;
        let rotationSpeed = 0.002;
        let movementSpeed = 0.2;
        let isWireframe = false;
        let cameraDistance = 100;
        let rotationX = 0;
        let rotationZ = 0;
        let isLeftDragging = false;
        let isMiddleDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        let models = [];
        let activeModelId = -1;

        let rotationSensitivity = 0.005;
        let panSensitivity = 2.5;

        let touchStart = {
            touches: 0,
            distance: 0,
            center: { x: 0, y: 0 },
            rotation: { x: 0, z: 0 },
            distance: 0
        };

        const keys = {
            w: false, a: false, s: false, d: false,
            ArrowUp: false, ArrowDown: false
        };

        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        const modelUrls = [
            'http://cdn.cdut.top/model.glb',
            'https://pub-c10bffdb38f848acb95ca9b5510a80f3.r2.dev/model.glb'
        ];
        let currentUrlIndex = 0;

        const canvas = document.getElementById('viewerCanvas');
        const initialLoading = document.getElementById('initialLoading');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const loadingStatusText = document.getElementById('loadingStatusText');
        const progressBar = document.getElementById('progressBar');
        const uploadPrompt = document.getElementById('uploadPrompt');
        const controlPanel = document.getElementById('controlPanel');
        const modelsPanel = document.getElementById('buildingsPanel');
        const modelsList = document.getElementById('buildingsList');
        const modelSearch = document.getElementById('buildingSearch');
        const fpsCounter = document.getElementById('fpsCounter');

        function checkThreeJsLoaded() {
            if (typeof THREE === 'undefined') {
                document.getElementById('initialLoading').classList.add('hidden');
                document.getElementById('resourceError').classList.remove('hidden');
                return false;
            }
            return true;
        }

        function showConnectionToast() {
            const toast = document.getElementById('connectionToast');
            toast.classList.add('opacity-100');

            setTimeout(() => {
                toast.classList.remove('opacity-100');
            }, 2000);
        }

        function initApplication() {
            console.log('初始化应用程序');

            if (!checkThreeJsLoaded()) return;

            setTimeout(() => {
                document.getElementById('initialLoading').classList.add('hidden');

                
                loadModelWithFallback();

                hideModelsPanel();

                updateFPS();
            }, 500);

            initScene();

            setupSearchFunctionality();

            document.getElementById('toggleBuildingsBtn').addEventListener('click', () => {
                toggleModelsPanel();
            });

            if (window.innerWidth < 768) {
                hideModelsPanel();
            }
        }

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;

                if (fpsCounter) {
                    fpsCounter.textContent = `${fps} FPS`;

                    if (fps > 55) {
                        fpsCounter.className = 'data-value mobile-fps-value text-neon-green';
                    } else if (fps > 30) {
                        fpsCounter.className = 'data-value mobile-fps-value text-neon-yellow';
                    } else {
                        fpsCounter.className = 'data-value mobile-fps-value text-neon-pink';
                    }
                }
            }
            requestAnimationFrame(updateFPS);
        }

        function showModelsPanel() {
            modelsPanel.classList.remove('hidden', 'opacity-0', 'pointer-events-none');
            modelsPanel.classList.add('opacity-100', 'pointer-events-auto');
        }

        function hideModelsPanel() {
            modelsPanel.classList.add('opacity-0', 'pointer-events-none');
            modelsPanel.classList.remove('opacity-100', 'pointer-events-auto');
        }

        function toggleModelsPanel() {
            if (modelsPanel.classList.contains('opacity-100')) {
                hideModelsPanel();
            } else {
                showModelsPanel();
            }
        }

        function setupSearchFunctionality() {
            modelSearch.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                filterModels(searchTerm);
            });

            filterModels('');
        }

        function filterModels(searchTerm) {
            modelsList.innerHTML = '';

            if (models.length === 0) {
                const noModelMsg = document.createElement('div');
                noModelMsg.className = 'text-neon-blue/60 text-sm text-center py-4';
                noModelMsg.textContent = '未識別到建築';
                modelsList.appendChild(noModelMsg);
                return;
            }

            let filteredModels = models.filter(model =>
                !model.name.toLowerCase().includes('补丁')
            );

            if (searchTerm.length > 0) {
                filteredModels = filteredModels.filter(model =>
                    model.name.toLowerCase().includes(searchTerm)
                );
            }

            if (filteredModels.length > 0) {
                filteredModels.sort((a, b) => a.name.localeCompare(b.name));

                filteredModels.forEach(model => {
                    const listItem = document.createElement('div');
                    listItem.className = `building-list-item ${activeModelId === model.id ? 'active' : ''}`;
                    listItem.textContent = model.name;
                    listItem.dataset.modelId = model.id;

                    listItem.addEventListener('click', () => {
                        moveToModel(model.id);
                    });

                    modelsList.appendChild(listItem);
                });
            } else {
                const noResult = document.createElement('div');
                noResult.className = 'text-neon-blue/60 text-sm text-center py-4';
                noResult.textContent = '未找到匹配的建築';
                modelsList.appendChild(noResult);
            }
        }

        function initScene() {
            console.log('初始化3D场景');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a12);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(10, 20, 15);
            directionalLight.distance = 5000;
            directionalLight.decay = 0;
            scene.add(directionalLight);

            const neonLight1 = new THREE.PointLight(0x00f3ff, 0.4, 2000);
            neonLight1.position.set(20, 10, 0);
            neonLight1.decay = 0;
            scene.add(neonLight1);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.8;

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enabled = false;

            rotationX = THREE.MathUtils.degToRad(60);
            rotationZ = THREE.MathUtils.degToRad(-90);

            updateCameraPosition();

            canvas.style.position = 'relative';
            canvas.style.zIndex = '10';

            setupEventListeners();

            animate();
        }

        function getDistance(touch1, touch2) {
            const dx = touch2.clientX - touch1.clientX;
            const dy = touch2.clientY - touch1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getCenter(touch1, touch2) {
            return {
                x: (touch1.clientX + touch2.clientX) / 2,
                y: (touch1.clientY + touch2.clientY) / 2
            };
        }

        function setupEventListeners() {
            console.log('设置事件监听器');
            const canvasElement = document.getElementById('viewerCanvas');

            canvasElement.tabIndex = 1;
            canvasElement.style.touchAction = 'none';

            document.addEventListener('mousedown', (event) => {
                if (event.target === canvasElement) {
                    if (event.button === 0) {
                        console.log('左键按下 - 开始旋转');
                        isLeftDragging = true;
                        previousMousePosition = {
                            x: event.clientX,
                            y: event.clientY
                        };
                    }
                    else if (event.button === 1) {
                        console.log('中键按下 - 开始平移');
                        isMiddleDragging = true;
                        previousMousePosition = {
                            x: event.clientX,
                            y: event.clientY
                        };
                    }
                    canvasElement.focus();
                    event.preventDefault();
                    event.stopPropagation();
                }
            }, true);

            document.addEventListener('mousemove', (event) => {
                if (isLeftDragging && !isOrbiting) {
                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;

                    rotationZ -= deltaX * rotationSensitivity;
                    rotationX += deltaY * rotationSensitivity;

                    rotationX = Math.max(0, Math.min(Math.PI / 2, rotationX));

                    updateCameraPosition();

                    previousMousePosition = {
                        x: event.clientX,
                        y: event.clientY
                    };

                    event.preventDefault();
                    event.stopPropagation();
                }
                else if (isMiddleDragging) {
                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;

                    const panX = deltaX * (movementSpeed * panSensitivity);
                    const panZ = deltaY * (movementSpeed * panSensitivity);

                    panCamera(panX, 0, panZ);

                    previousMousePosition = {
                        x: event.clientX,
                        y: event.clientY
                    };

                    event.preventDefault();
                    event.stopPropagation();
                }
            }, true);

            document.addEventListener('mouseup', (event) => {
                if (event.button === 0 && isLeftDragging) {
                    console.log('左键释放 - 结束旋转');
                    isLeftDragging = false;
                    event.preventDefault();
                    event.stopPropagation();
                }
                else if (event.button === 1 && isMiddleDragging) {
                    console.log('中键释放 - 结束平移');
                    isMiddleDragging = false;
                    event.preventDefault();
                    event.stopPropagation();
                }
            }, true);

            canvasElement.addEventListener('touchstart', (event) => {
                event.preventDefault();
                const touches = event.touches;

                if (touches.length === 1) {
                    touchStart.touches = 1;
                    touchStart.center = {
                        x: touches[0].clientX,
                        y: touches[0].clientY
                    };
                    touchStart.rotation = { x: rotationX, z: rotationZ };
                }
                else if (touches.length === 2) {
                    touchStart.touches = 2;
                    touchStart.distance = getDistance(touches[0], touches[1]);
                    touchStart.center = getCenter(touches[0], touches[1]);
                    touchStart.previousCenter = { ...touchStart.center };
                    touchStart.initialDistance = cameraDistance;
                }
            }, { passive: false });

            canvasElement.addEventListener('touchmove', (event) => {
                event.preventDefault();
                const touches = event.touches;

                if (touches.length === 1 && touchStart.touches === 1) {
                    const currentCenter = {
                        x: touches[0].clientX,
                        y: touches[0].clientY
                    };

                    const deltaX = currentCenter.x - touchStart.center.x;
                    const deltaY = currentCenter.y - touchStart.center.y;

                    rotationZ = touchStart.rotation.z - deltaX * rotationSensitivity;
                    rotationX = touchStart.rotation.x + deltaY * rotationSensitivity;

                    rotationX = Math.max(0, Math.min(Math.PI / 2, rotationX));

                    updateCameraPosition();
                }
                else if (touches.length === 2 && touchStart.touches === 2) {
                    const currentDistance = getDistance(touches[0], touches[1]);
                    const currentCenter = getCenter(touches[0], touches[1]);

                    const scale = currentDistance / touchStart.distance;
                    cameraDistance = touchStart.initialDistance / scale;

                    const deltaX = currentCenter.x - touchStart.previousCenter.x;
                    const deltaY = currentCenter.y - touchStart.previousCenter.y;

                    const panX = deltaX * (movementSpeed * panSensitivity * 2);
                    const panY = deltaY * (movementSpeed * panSensitivity * 2);

                    panCamera(panX, panY, 0);

                    touchStart.previousCenter = { ...currentCenter };

                    updateCameraPosition();
                }
            }, { passive: false });

            canvasElement.addEventListener('touchend', (event) => {
                touchStart.touches = 0;
            });

            canvasElement.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                return false;
            });

            canvasElement.addEventListener('wheel', (event) => {
                event.preventDefault();

                if (event.deltaY < 0) {
                    cameraDistance = cameraDistance * 0.95;
                } else {
                    cameraDistance = cameraDistance * 1.05;
                }

                updateCameraPosition();
            });

            canvasElement.addEventListener('dblclick', (event) => {
                if (!model) return;

                const rect = canvasElement.getBoundingClientRect();
                let clientX, clientY;

                if (event.type === 'dblclick' && event.touches) {
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else {
                    clientX = event.clientX;
                    clientY = event.clientY;
                }

                const mouse = new THREE.Vector2();
                mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(model, true);

                if (intersects.length > 0) {
                    const newCenter = intersects[0].point;
                    updateCameraTarget(newCenter);
                }
            });

            window.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = true;
                }
            });

            window.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = false;
                }
            });

            window.addEventListener('resize', onWindowResize);

            setupControlPanelEvents();
        }

        function identifyModels(model) {
            models = [];
            let modelId = 0;

            model.traverse(child => {
                if (child.isMesh) {
                    const box = new THREE.Box3().setFromObject(child);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    let modelName = child.name || `建筑 ${modelId + 1}`;
                    modelName = modelName.replace(/_/g, ' ');

                    models.push({
                        id: modelId,
                        name: modelName,
                        object: child,
                        position: center,
                        size: size,
                        height: size.y,
                        viewDistance: Math.max(size.x, size.y, size.z) * 2
                    });

                    modelId++;
                }
            });

            if (models.length === 0 && model.isObject3D) {
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                models.push({
                    id: 0,
                    name: "主建筑",
                    object: model,
                    position: center,
                    size: size,
                    height: size.y,
                    viewDistance: Math.max(size.x, size.y, size.z) * 2
                });
            }

            console.log(`识别到 ${models.length} 个建筑`);
            filterModels(modelSearch.value.toLowerCase().trim());
        }

        function moveToModel(modelId) {
            const model = models.find(m => m.id === modelId);
            if (!model) return;

            activeModelId = modelId;
            filterModels(modelSearch.value.toLowerCase().trim());

            isOrbiting = false;
            document.getElementById('cameraOrbitToggle').classList.remove('bg-primary/20');
            document.getElementById('mobileOrbitToggle').classList.remove('bg-primary/20');

            cameraTarget.copy(model.position);

            cameraDistance = model.viewDistance;

            rotationX = Math.PI * 0.15;
            rotationZ = Math.PI * 0.25;

            updateCameraPosition();

            if (window.innerWidth < 768) {
                hideModelsPanel();
            }
        }

        function updateCameraTarget(newTarget) {
            cameraTarget.copy(newTarget);
            updateCameraPosition();
        }

        function setupControlPanelEvents() {
            const orbitToggleElements = [
                document.getElementById('cameraOrbitToggle'),
                document.getElementById('mobileOrbitToggle')
            ];

            orbitToggleElements.forEach(el => {
                if (el) {
                    el.addEventListener('click', () => {
                        isOrbiting = !isOrbiting;
                        orbitToggleElements.forEach(btn => {
                            btn.classList.toggle('bg-primary/20', isOrbiting);
                        });
                    });
                }
            });

            const resetViewElements = [
                document.getElementById('resetView'),
                document.getElementById('mobileResetView')
            ];

            resetViewElements.forEach(el => {
                if (el) {
                    el.addEventListener('click', () => {
                        cameraDistance = 100;
                        rotationX = THREE.MathUtils.degToRad(60);
                        rotationZ = THREE.MathUtils.degToRad(-90);
                        cameraTarget.set(0, 0, 0);
                        activeModelId = -1;
                        filterModels(modelSearch.value.toLowerCase().trim());

                        if (model) {
                            const box = new THREE.Box3().setFromObject(model);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());
                            const maxDim = Math.max(size.x, size.y, size.z);
                            const fov = camera.fov * (Math.PI / 180);
                            cameraDistance = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.8;
                            cameraTarget.copy(center);
                        }

                        camera.position.set(-840, 1050, -140);
                        camera.lookAt(cameraTarget);

                        isOrbiting = false;
                        orbitToggleElements.forEach(btn => {
                            btn.classList.remove('bg-primary/20');
                        });
                    });
                }
            });

            document.getElementById('zoomIn').addEventListener('click', () => {
                cameraDistance = cameraDistance * 0.8;
                updateCameraPosition();
            });

            document.getElementById('zoomOut').addEventListener('click', () => {
                cameraDistance = cameraDistance * 1.25;
                updateCameraPosition();
            });

            const wireframeElements = [
                document.getElementById('wireframeToggle'),
                document.getElementById('mobileWireframeToggle')
            ];

            wireframeElements.forEach(el => {
                if (el) {
                    el.addEventListener('click', () => {
                        isWireframe = !isWireframe;
                        wireframeElements.forEach(btn => {
                            btn.classList.toggle('bg-primary/20', isWireframe);
                        });

                        if (model) {
                            model.traverse(child => {
                                if (child.isMesh && child.material) {
                                    child.material.wireframe = isWireframe;

                                    if (isWireframe) {
                                        child.material.emissive = new THREE.Color(0x00f3ff);
                                        child.material.emissiveIntensity = 0.5;
                                    } else {
                                        child.material.emissive = new THREE.Color(0x000000);
                                        child.material.emissiveIntensity = 0;
                                    }
                                }
                            });
                        }
                    });
                }
            });

            document.getElementById('fullscreenBtn').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err =>
                        console.error('全屏错误:', err)
                    );
                } else {
                    document.exitFullscreen();
                }
            });

            document.getElementById('infoBtn').addEventListener('click', () => {
                document.getElementById('infoModal').classList.remove('hidden');
                setTimeout(() => {
                    document.getElementById('modalContent').classList.remove('scale-95', 'opacity-0');
                }, 10);
            });

            document.getElementById('closeInfoBtn').addEventListener('click', () => {
                const modal = document.getElementById('modalContent');
                modal.classList.add('scale-95', 'opacity-0');
                setTimeout(() => {
                    document.getElementById('infoModal').classList.add('hidden');
                }, 300);
            });
        }

        function updateCameraPosition() {
            if (!camera) return;

            const x = Math.sin(rotationZ) * Math.cos(rotationX) * cameraDistance;
            const y = Math.sin(rotationX) * cameraDistance;
            const z = Math.cos(rotationZ) * Math.cos(rotationX) * cameraDistance;

            const targetX = cameraTarget.x + x;
            const targetY = cameraTarget.y + y;
            const targetZ = cameraTarget.z + z;

            const clampedX = Math.max(-2000, Math.min(2000, targetX));
            const clampedY = Math.max(0, Math.min(2000, targetY));
            const clampedZ = Math.max(-2000, Math.min(2000, targetZ));

            camera.position.set(clampedX, clampedY, clampedZ);

            if (cameraLight) {
                cameraLight.position.copy(camera.position);
            }

            camera.lookAt(cameraTarget);
            renderer.render(scene, camera);
        }

        function panCamera(x, y, z) {
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3().crossVectors(camera.up, forward);
            right.normalize();

            cameraTarget.add(right.multiplyScalar(x));
            cameraTarget.y += y;
            cameraTarget.add(forward.multiplyScalar(z));

            cameraTarget.x = Math.max(-2000, Math.min(2000, cameraTarget.x));
            cameraTarget.y = Math.max(-2000, Math.min(2000, cameraTarget.y));
            cameraTarget.z = Math.max(-2000, Math.min(2000, cameraTarget.z));

            updateCameraPosition();
        }

        function processKeyboardMovement() {
            const moveDistance = movementSpeed * 3;

            if (keys.w) {
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                panCamera(0, 0, moveDistance);
            }
            if (keys.s) {
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                panCamera(0, 0, -moveDistance);
            }
            if (keys.a) {
                const right = new THREE.Vector3();
                camera.getWorldDirection(right);
                right.cross(camera.up);
                right.y = 0;
                right.normalize();
                panCamera(moveDistance, 0, 0);
            }
            if (keys.d) {
                const right = new THREE.Vector3();
                camera.getWorldDirection(right);
                right.cross(camera.up);
                right.y = 0;
                right.normalize();
                panCamera(-moveDistance, 0, 0);
            }

            if (keys.ArrowUp) {
                panCamera(0, moveDistance, 0);
            }
            if (keys.ArrowDown) {
                panCamera(0, -moveDistance, 0);
            }
        }

        function onWindowResize() {
            if (!camera || !renderer) return;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

       
        function loadModelWithFallback() {
            if (!checkThreeJsLoaded()) return;

            
            if (currentUrlIndex >= modelUrls.length) {
                loadingIndicator.classList.add('hidden');
                progressBar.style.width = '0%';
                alert('所有伺服器均連接失敗');
                return;
            }

            const currentUrl = modelUrls[currentUrlIndex];
            const loader = new THREE.GLTFLoader();

            loadingIndicator.classList.remove('hidden');
            progressBar.style.width = '0%';
            loadingStatusText.textContent = `伺服器 ${currentUrlIndex + 1}/${modelUrls.length} 通信中...`;

            loader.load(
                currentUrl,
                (gltf) => {
                    if (model) {
                        scene.remove(model);
                    }

                    model = gltf.scene;

                    identifyModels(model);

                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);

                    const fov = camera.fov * (Math.PI / 180);
                    cameraDistance = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.8;
                    cameraTarget.copy(center);

                    rotationX = THREE.MathUtils.degToRad(60);
                    rotationZ = THREE.MathUtils.degToRad(-90);

                    camera.position.set(-840, 1050, -140);
                    camera.lookAt(cameraTarget);

                    model.traverse(child => {
                        if (child.isMesh && child.material) {
                            child.material.wireframe = isWireframe;

                            if (isWireframe) {
                                child.material.emissive = new THREE.Color(0x00f3ff);
                                child.material.emissiveIntensity = 0.5;
                            }
                        }
                    });

                    scene.add(model);
                    renderer.render(scene, camera);

                    
                    currentUrlIndex = 0;

                    setTimeout(() => {
                        loadingIndicator.classList.add('hidden');
                        progressBar.style.width = '0%';
                        showConnectionToast();
                    }, 500);

                    controlPanel.classList.remove('opacity-50', 'pointer-events-none');
                    controlPanel.classList.add('opacity-100', 'pointer-events-auto');
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total) * 100;
                    progressBar.style.width = percent + '%';
                },
                (error) => {
                    console.error(`与 ${currentUrl} 通信失敗:`, error);

                   
                    currentUrlIndex++;
                    setTimeout(() => {
                        loadModelWithFallback();
                    }, 1000);
                }
            );
        }

        function animate() {
            requestAnimationFrame(animate);

            processKeyboardMovement();

            if (isOrbiting) {
                rotationZ += rotationSpeed;
                updateCameraPosition();
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        document.getElementById('retryLoadResources').addEventListener('click', () => {
            document.getElementById('resourceError').classList.add('hidden');
            document.getElementById('initialLoading').classList.remove('hidden');
            
            currentUrlIndex = 0;
            setTimeout(initApplication, 500);
        });

        window.addEventListener('load', initApplication);
    </script>
</body>
</html>

